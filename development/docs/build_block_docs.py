import os
import re
from typing import List, Set, Tuple, Type

from inference.core.utils.file_system import dump_text_lines, read_text_file
from inference.enterprise.workflows.entities.steps import OutputDefinition
from inference.enterprise.workflows.execution_engine.compiler.blocks_loader import (
    describe_available_blocks,
)
from inference.enterprise.workflows.execution_engine.introspection.connections_discovery import (
    discover_blocks_connections,
)
from inference.enterprise.workflows.execution_engine.introspection.schema_parser import (
    parse_block_manifest_schema,
)
from inference.enterprise.workflows.prototypes.block import WorkflowBlock

DOCS_ROOT_DIR = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        "..",
        "..",
        "docs",
    )
)

BLOCK_DOCUMENTATION_FILE = os.path.join(DOCS_ROOT_DIR, "workflows", "blocks.md")
BLOCK_DOCUMENTATION_DIRECTORY = os.path.join(DOCS_ROOT_DIR, "workflows", "blocks")
AUTOGENERATED_BLOCKS_LIST_TOKEN = "<!--- AUTOGENERATED_BLOCKS_LIST -->"

USER_CONFIGURATION_HEADER = [
    "| **Name** | **Type** | **Description** | Refs |",
    "|:---------|:---------|:----------------|:-----|",
]

BLOCK_DOCUMENTATION_TEMPLATE = """
# {class_name}

{description}

## Properties

{block_inputs}

The **Refs** column marks possibility to parametrise the property with dynamic values available 
in `workflow` runtime. See *Bindings* for more info.

## Available Connections

Check what blocks you can connect to `{class_name}`.

- inputs: {input_connections}
- outputs: {output_connections}

The available connections depend on its binding kinds. Check what binding kinds 
`{class_name}` has.

??? tip "Bindings"

    - input
    
{block_input_bindings}

    - output
    
{block_output_bindings}
"""

BLOCK_CARD_TEMPLATE = '<p class="card block-card" data-url="{data_url}" data-name="{data_name}" data-desc="{data_desc}" data-labels="{data_labels}" data-author="{data_authors}"></p>\n'


def main() -> None:
    os.makedirs(BLOCK_DOCUMENTATION_DIRECTORY, exist_ok=True)
    lines = read_text_file(
        path=BLOCK_DOCUMENTATION_FILE,
        split_lines=True,
    )
    start_index, end_index = get_auto_generation_markers(
        documentation_lines=lines,
    )
    block_card_lines = []
    blocks_description = describe_available_blocks()
    blocks_connections = discover_blocks_connections(
        blocks_description=blocks_description
    )
    for block in blocks_description.blocks:
        block_class_name = get_class_name(block.fully_qualified_class_name)
        block_type = block.block_schema.get("block_type", "").upper()
        block_license = block.block_schema.get("license", "").upper()

        short_description = block.block_schema.get("short_description", "")
        long_description = block.block_schema.get("long_description", "")

        documentation_file_name = camel_to_snake(block_class_name) + ".md"
        documentation_file_path = os.path.join(
            BLOCK_DOCUMENTATION_DIRECTORY, documentation_file_name
        )
        documentation_content = BLOCK_DOCUMENTATION_TEMPLATE.format(
            class_name=block_class_name,
            description=long_description,
            block_inputs=format_block_inputs(block.block_schema),
            block_input_bindings=format_input_bindings(block.block_schema),
            block_output_bindings=format_block_outputs(block.outputs_manifest),
            input_connections=format_block_connections(
                connections=blocks_connections.input_connections.block_wise[
                    block.block_class
                ]
            ),
            output_connections=format_block_connections(
                connections=blocks_connections.output_connections.block_wise[
                    block.block_class
                ]
            ),
        )
        with open(documentation_file_path, "w") as documentation_file:
            documentation_file.write(documentation_content)

        block_card_line = BLOCK_CARD_TEMPLATE.format(
            data_url=camel_to_snake(block_class_name),
            data_name=block_class_name_to_block_title(block_class_name),
            data_desc=short_description,
            data_labels=", ".join([block_type, block_license]),
            data_authors="",
        )
        block_card_lines.append(block_card_line)

    lines = lines[: start_index + 1] + block_card_lines + lines[end_index:]
    dump_text_lines(
        path=BLOCK_DOCUMENTATION_FILE,
        content=lines,
        allow_override=True,
        lines_connector="",
    )


def get_auto_generation_markers(documentation_lines: List[str]) -> Tuple[int, int]:
    lines_with_token_indexes = search_lines_with_token(
        lines=documentation_lines, token=AUTOGENERATED_BLOCKS_LIST_TOKEN
    )
    if len(lines_with_token_indexes) != 2:
        raise RuntimeError(
            f"Please inject two {AUTOGENERATED_BLOCKS_LIST_TOKEN} "
            f"tokens to signal start and end of autogenerated table."
        )
    return lines_with_token_indexes[0], lines_with_token_indexes[-1]


def search_lines_with_token(lines: List[str], token: str) -> List[int]:
    result = []
    for line_index, line in enumerate(lines):
        if token in line:
            result.append(line_index)
    return result


def camel_to_snake(name: str) -> str:
    name = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    name = re.sub("([a-z0-9])([A-Z])", r"\1_\2", name)
    return name.lower()


def block_class_name_to_block_title(name: str) -> str:
    words = re.findall(r"[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))", name)

    if words[-1] == "Block":
        words.pop()

    return " ".join(words)


def format_block_inputs(block_schema: dict) -> str:
    parsed_schema = parse_block_manifest_schema(schema=block_schema)
    rows = []
    for input_description in parsed_schema.primitive_types.values():
        ref_appear = input_description.property_name in parsed_schema.selectors
        rows.append(
            f"| `{input_description.property_name}` | `{input_description.type_annotation}` | "
            f"{input_description.property_description}. | {'✅' if ref_appear else '❌'} |"
        )
    return "\n".join(USER_CONFIGURATION_HEADER + rows)


def format_input_bindings(block_schema: dict) -> str:
    parsed_schema = parse_block_manifest_schema(schema=block_schema)
    rows = []
    for selector in parsed_schema.selectors.values():
        rows.append(
            f"        - `{selector.property_name}` (`{selector.to_type_annotation()}`): {selector.property_description}."
        )
    return "\n".join(rows)


def format_block_outputs(outputs_manifest: List[OutputDefinition]) -> str:
    rows = []

    for output in outputs_manifest:
        if len(output.kind) == 1:
            kind = output.kind[0].name
            description = output.kind[0].description
            rows.append(f"        - `{output.name}` (`{kind}`): {description}.")
        else:
            kind = ", ".join([k.name for k in output.kind])
            description = " or ".join(
                [f"{k.description} if `{k.name}`" for k in output.kind]
            )
            rows.append(f"        - `{output.name}` (`Union[{kind}]`): {description}.")

    return "\n".join(rows)


def get_class_name(fully_qualified_name: str) -> str:
    return fully_qualified_name.split(".")[-1]


def format_block_connections(connections: Set[Type[WorkflowBlock]]) -> str:
    if len(connections) == 0:
        return "None"
    connections = [
        f"[`{connection.__name__}`](/workflows/blocks/{camel_to_snake(connection.__name__)})"
        for connection in connections
    ]
    return ", ".join(connections)


if __name__ == "__main__":
    main()
