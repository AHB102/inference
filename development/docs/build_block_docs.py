from typing import List

from inference.enterprise.workflows.execution_engine.compiler.blocks_loader import (
    describe_available_blocks,
)

import re
import os


BLOCK_DOCUMENTATION_FILE = os.path.join(os.getcwd(), 'docs', 'workflows', 'blocks.md')
BLOCK_DOCUMENTATION_DIRECTORY = os.path.join(os.getcwd(), 'docs', 'workflows', 'blocks')
AUTOGENERATED_BLOCKS_LIST_TOKEN = "<!--- AUTOGENERATED_BLOCKS_LIST -->"


BLOCK_DOCUMENTATION_TEMPLATE = """
# `{class_name}`

{description}
"""

BLOCK_CARD_TEMPLATE = '<p class="card block-card" data-url="{data_url}" data-name="{data_name}" data-desc="{data_desc}" data-labels="{data_labels}" data-author="{data_authors}"></p>'


def read_lines_from_file(path: str) -> List[str]:
    with open(path) as file:
        return [line.rstrip() for line in file]


def save_lines_to_file(path: str, lines: List[str]) -> None:
    with open(path, "w") as f:
        for line in lines:
            f.write("%s\n" % line)


def search_lines_with_token(lines: List[str], token: str) -> List[int]:
    result = []
    for line_index, line in enumerate(lines):
        if token in line:
            result.append(line_index)
    return result


def camel_to_snake(name: str) -> str:
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def block_class_name_to_block_title(name: str) -> str:
    words = re.findall(r'[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))', name)

    if words[-1] == "Block":
        words.pop()

    return ' '.join(words)


def get_class_name(fully_qualified_name: str) -> str:
    return fully_qualified_name.split('.')[-1]


def create_directory_if_not_exists(directory_path: str) -> None:
    if not os.path.exists(directory_path):
        os.makedirs(directory_path)


create_directory_if_not_exists(BLOCK_DOCUMENTATION_DIRECTORY)

lines = read_lines_from_file(path=BLOCK_DOCUMENTATION_FILE)
lines_with_token_indexes = search_lines_with_token(
        lines=lines, token=AUTOGENERATED_BLOCKS_LIST_TOKEN)

if len(lines_with_token_indexes) != 2:
    raise Exception(f"Please inject two {AUTOGENERATED_BLOCKS_LIST_TOKEN} "
                    f"tokens to signal start and end of autogenerated table.")

[start_index, end_index] = lines_with_token_indexes

block_card_lines = []

for block in describe_available_blocks().blocks:
    block_class_name = get_class_name(block.fully_qualified_class_name)
    block_type = block.block_manifest['block_type']
    block_description = block.block_manifest['description']
    documentation_file_name = camel_to_snake(block_class_name) + '.md'
    documentation_file_path = os.path.join(
        BLOCK_DOCUMENTATION_DIRECTORY,
        documentation_file_name
    )
    documentation_content = BLOCK_DOCUMENTATION_TEMPLATE.format(
        class_name=block_class_name,
        description=block_description
    )
    with open(documentation_file_path, 'w') as documentation_file:
        documentation_file.write(documentation_content)

    block_card_line = BLOCK_CARD_TEMPLATE.format(
        data_url=camel_to_snake(block_class_name),
        data_name=block_class_name_to_block_title(block_class_name),
        data_desc=block_description,
        data_labels=block_type.upper(),
        data_authors=''
    )
    block_card_lines.append(block_card_line)

lines = lines[:start_index + 1] + block_card_lines + lines[end_index:]
save_lines_to_file(path=BLOCK_DOCUMENTATION_FILE, lines=lines)
